// -----------------------------------------
// Runtime model
// Notice that we can hold at most one permission
// to *fields*, but this does not apply to *predicates*
predicate time_credit() // represents one abstract unit of time

// models spending an abstract unit of time 
// needs to be called at the beginning of every method
// and loop iteration
method consume_time_credit() // 
    requires acc(time_credit(), 1/1)
// -----------------------------------------


// -----------------------------------------
// Object model
// You can add ghost fields if you want.

// Fields of dynamic array objects
field length: Int // how many elements are currently stored in the array
field capacity: Int // how many elements can be stored in the array
field array: StaticArray // the static array storing the actual elements, see below


// Fields of individual array elements
field entry: Int // the value of the array element

//fieldfor stored time credits
field saved_credits: Int
//if you have credits then you can have acc to time_credits (mianly for grow())
// -----------------------------------------


// -----------------------------------------
// Static arrays with field entry as in module 11
domain StaticArray {
    function loc(a: StaticArray, i: Int): Ref
    function len(a: StaticArray): Int
    function first(r: Ref): StaticArray
    function second(r: Ref): Int

    axiom injectivity {
        forall a: StaticArray, i: Int :: {loc(a, i)}
        first(loc(a, i)) == a && second(loc(a, i)) == i
    }

    axiom length_nonneg {
        forall a: StaticArray :: len(a) >= 0
    }
}
// -----------------------------------------

// -----------------------------------------
// Shortcuts for using static arrays

// a[i] for static array a
define lookup(a, i)
    loc(a, i).entry

// a[i] := e for static array a
define update(a, i, e) { 
    loc(a, i).entry := e
}

// Permissions to elements of static array a
define staticArray(a)
    (forall i: Int :: {loc(a, i)}  0 <= i && i < len(a) ==> acc(loc(a, i).entry)) 

// Allocate a new static array a of length l
// You can (reasonably) use this to create a new array
// Warning: do not use twice with the same arguments.
define alloc(a, l) {
    inhale staticArray(a) && len(a) == l
}
// -----------------------------------------


// -----------------------------------------
// TASK 3.1: Give a predicate modelling the data structure invariants and permissions
//         of dynamic arrays. You may also store other (ghost) information
//         such as time credits needed for amortized analysis.
//         Feel free to add acessor functions to simplify fold-unfold reasoning.
predicate dyn_array(self: Ref) {
    //permissions
    acc(self.saved_credits) &&
    acc(self.length) && acc(self.capacity) && acc(self.array) &&
    staticArray(self.array) && //quantified permission
    //representation invariants (restrictions)
    (self.capacity > 1) &&
    (self.length >= 0) &&
    (self.capacity > self.length)&&
    (len(self.array) == self.capacity)&&
    //time credits invariant
    self.saved_credits >= 0 &&
    (self.saved_credits + (self.capacity - self.length - 1)*2) >= self.capacity - 1 &&//need -1 for both there bc we never fill last index
    acc(time_credit(),self.saved_credits/1)
    //also we need >= because theres always an excess # of credits in the inital adding
    //but the relationship should be ==

    //old invariant
    // self.saved_credits >= 0 && 
    // (self.has_acc  
    //     ?acc(time_credit(), self.saved_credits / 1) //&&  self.saved_credits >= self.length
    //     :self.saved_credits == 0
    // )

}
    
//Helper function to get seq of contents
function static_array_contents(base: StaticArray, end: Int): Seq[Int]
    requires end >= 0
    requires end <= len(base)
    requires (staticArray(base))
    ensures |result| == end
    ensures forall i: Int :: 0 <= i && i < end ==> result[i] == loc(base,i).entry

{
    end == 0 ? Seq[Int]()
            : static_array_contents(base, end - 1) ++ Seq(loc(base, end - 1).entry)
}

// Accessor functions for commonly needed fields
function arr_length(base: Ref): Int 
    requires dyn_array(base)
    ensures result>=0
    
{
    unfolding dyn_array(base) in
    base.length
    
}

// Feel free to also implement acessor or abstraction functions to simplify fold-unfold reasoning.
// -----------------------------------------


// -----------------------------------------
// TASK 3.2: Implement a proven-correct method that creates a new dynamic array of length 0
//         with the given capacity.
//         You should at least prove that your method indeed creates a dynamic array of the 
//         given capacity that satisfies all data structure invariants of dynamic arrays.
// Remember to require sufficiently many time credits.
method cons(_capacity: Int) returns (arr: Ref)
    //requires
    requires acc(time_credit(),1/1)
    requires 1 < _capacity

    //ensures
    ensures dyn_array(arr)
    ensures unfolding dyn_array(arr) in (arr.capacity == _capacity)
{
    consume_time_credit() // every method call must consume a time credit

    arr := new (length,capacity,array,saved_credits)
    arr.capacity := _capacity
    arr.length := 0
    var a: StaticArray
    arr.array := a
    alloc(arr.array,_capacity)
    arr.saved_credits := 0
    fold dyn_array(arr)

    
}
// -----------------------------------------



// -----------------------------------------
// TASK 3.3: Define an abstraction function that maps a dynamic array to the 
//         mathematical sequence of values stored in its elements.
// For other tasks, you might have to prove additional properties about the abstraction.
function arr_contents(base: Ref): Seq[Int]
    requires dyn_array(base)
    
{
    unfolding dyn_array(base) in
    static_array_contents(base.array,base.length)
    
}

// -----------------------------------------
//gets boolean if theres space for one more
function can_append(base: Ref): Bool
    requires dyn_array(base)
{
    unfolding dyn_array(base) in 
    base.length + 1 < base.capacity
}


// -----------------------------------------
// TASK 3.4: Prove that this method appends the value val to the dynamic array
//         without increasing the capacity first.
//         You must prove memory safety and preservation of the dynamic array's data structure invariants.
//         Furthermore, use your abstraction to prove that val has been correctly appended.
//         This method can only be called if there is enough space left in the dynamic array.
//         For amortized analysis, we also want to save a time credit such that we can 
//         grow the array later if necessary.
//         You can add specifications and ghost code, but do not modify the production code
method append_nogrow(arr: Ref, val: Int)
    requires acc(time_credit(),4/1)
    requires dyn_array(arr)
    requires can_append(arr)

    ensures dyn_array(arr)
    ensures |arr_contents(arr)| == |old(arr_contents(arr))|+1
    ensures arr_contents(arr) == old(arr_contents(arr))++Seq(val)
    //ensures (arr_saved_credits(arr) == old(arr_saved_credits(arr)) + 2)||(arr_saved_credits(arr) == old(arr_saved_credits(arr)) + 3)

{
    consume_time_credit() 

    unfold dyn_array(arr)
    arr.saved_credits := arr.saved_credits+2 
    
    //loc(arr.array, arr.length).entry := val
    update(arr.array, arr.length, val) // append value
    arr.length := arr.length + 1 // we appended an element
    fold dyn_array(arr)
}
// -----------------------------------------

//gets capacity of the array of the ref
function arr_capacity(base: Ref): Int
    requires dyn_array(base)
{
    unfolding dyn_array(base) in
    base.capacity
}

function arr_saved_credits(base: Ref): Int
    requires dyn_array(base)
{
    unfolding dyn_array(base) in
        base.saved_credits
}

// -----------------------------------------
// TASK 3.5: Prove that the method grow creates a copy of the given array with
//         twice the capacity. 
//         Prove that all data structure invariants are preserved.
//         Furthermore, prove that the returned array has the right capacity
//         and that it indeed contains a copy of the original array, i.e. it
//         represents the same sequence of values.
//         For amortized analysis, your method may require only a *constant*
//         number of time credits, i.e. the number of time credits cannot depend
//         on any variable.
//         Hint: You may, of course, use additional time credits that have been stored
//               in your dynamic array for later use.
method grow(arr: Ref) returns (new_arr: Ref)
    requires dyn_array(arr)
    requires !can_append(arr)
    //time requirements
    requires acc(time_credit(),1/1)
    requires arr_length(arr) == arr_capacity(arr)-1

    ensures dyn_array(new_arr) //&& dyn_array(arr)
    ensures 2*old(arr_capacity(arr)) == arr_capacity(new_arr)
    //ensures that give additional context for other methods to work properly
    //ensures arr_contents(new_arr) == old(arr_contents(arr))
    ensures arr_length(new_arr) == old(arr_length(arr))
    
    
{
    consume_time_credit() // we must spend a credit for the call

    // create a new dynamic array with twice the capacity
    unfold dyn_array(arr)
    assert perm(time_credit())==arr.saved_credits/1
    assert arr.saved_credits > 0
    new_arr := new(length, capacity, array, saved_credits)
    new_arr.capacity := 2 * arr.capacity
    new_arr.length := arr.length
    alloc(new_arr.array, new_arr.capacity)
    var c: Int := arr.saved_credits
    new_arr.saved_credits := 0

    //fold dyn_array(arr) //useless
    // copy array elements iteratively; in each iteration, we use ghost credits to pay for the iteration
    // since we modify both the new array and ghost fields of the old array, we need a lot of invariants
    // to make sure all relevant properties are preserved
    var pos: Int := 0
    assert new_arr.length >= 0
    assert acc(time_credit(), (new_arr.length - pos)/1)
    while (pos < new_arr.length)
        //permissions
        invariant acc(new_arr.length) && acc(new_arr.saved_credits)
        invariant acc(new_arr.capacity) && acc(new_arr.array) && staticArray(new_arr.array)
        //perm for old array
        invariant acc(arr.length) && acc(arr.saved_credits)
        invariant acc(arr.capacity) && acc(arr.array) && staticArray(arr.array)
        //invariants necessary for the loop
        invariant (new_arr.capacity > 1)
        invariant (new_arr.length >= 0)
        invariant (new_arr.capacity > new_arr.length)
        invariant (len(new_arr.array) == new_arr.capacity)
        invariant 0 <= pos 
        invariant pos <= new_arr.length
        invariant new_arr.length == arr.length  
        invariant len(arr.array) == arr.capacity
        invariant arr.length < arr.capacity
        invariant new_arr.capacity == 2 * arr.capacity
        invariant acc(time_credit(), (new_arr.length - pos)/1)
        invariant new_arr.saved_credits == 0
        invariant 2*old(arr_capacity(arr)) == new_arr.capacity
        // invariant forall i: Int :: 0 <= i < pos ==>
        //     old(arr_contents(arr))[i] == static_array_contents(new_arr.array, pos)[i]
        invariant new_arr.length == old(arr_length(arr))

        // invariant dyn_array(new_arr) //&& dyn_array(arr) useless
        // invariant 0 <= pos <= arr_length(new_arr)
        // invariant arr_length(new_arr) == old(arr_length(arr))
        // //invariant arr_contents(arr) == old(arr_contents(arr)) useless
        // invariant forall i: Int :: 0 <= i < pos ==>
        //     old(arr_contents(arr))[i] == arr_contents(new_arr)[i]
        // //invariants necessary for the ensures at the end
        // invariant arr_capacity(new_arr) == 2 * old(arr_capacity(arr))
        // //i need to keep save credits non -ve in the loop
        // invariant unfolding dyn_array(new_arr) in
        //     new_arr.saved_credits >= new_arr.length - pos
    {
        consume_time_credit() // we must spend a credit for every iteration
        // copy one element 
        loc(new_arr.array, pos).entry := lookup(arr.array,pos)
        //update(new_arr.array, pos, lookup(arr.array,pos))
        //assert arr_contents(arr)[pos] == arr_contents(new_arr)[pos]
        pos := pos + 1
        

        
    }
    assert 2*old(arr_capacity(arr)) == new_arr.capacity
    fold dyn_array(new_arr)
    assert arr_capacity(new_arr) == 2*arr.capacity
    

    
}
// -----------------------------------------


// -----------------------------------------
// TASK 3.6: Prove that the following general append method
//         can be executed in *amortized constant time*
//         for dynamic arrays.
//         You may require that a certain number of time credits have been saved up
//         *in the data structure* that you can use for growing the data structure.
//         Furthermore, prove memory safety, perservation of data structure invariants
//         and that the method returns an array that correctly appends the value val. 
method append(arr: Ref, val: Int) returns (new_arr: Ref)
    requires dyn_array(arr)
    requires acc(time_credit(), 5/1)

    ensures dyn_array(new_arr)
    //ensures arr_contents(new_arr) == old(arr_contents(arr)) ++ Seq(val)

{
    consume_time_credit() // we must spend a time credit for the call
    unfold dyn_array(arr)
    //I need some ghost variable to hold old length to help prove new_arr.capacity > new_arr.length;
    // do we have space left?
    if (arr.length + 1 == arr.capacity) {
        fold dyn_array(arr)
        // no, we need to grow the array first
        assert arr_saved_credits(arr) >= arr_length(arr)
        new_arr := grow(arr)
        unfold dyn_array(new_arr)
        
        // append element
        update(new_arr.array, new_arr.length, val)
        new_arr.length := new_arr.length + 1

        new_arr.saved_credits := new_arr.saved_credits + 1

        assert new_arr.capacity > new_arr.length;
        fold dyn_array(new_arr)

    } else {
        assert (arr.length + 1) < arr.capacity
        fold dyn_array(arr)
        // yes, we can append without growing the array first
        new_arr := arr
        append_nogrow(new_arr, val)
    }   
    
}
// -----------------------------------------
