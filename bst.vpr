// -----------------------------------------
// Runtime model
// Notice that we can hold at most one permission
// to *fields*, but this does not apply to *predicates*
predicate time_credit() // represents one abstract unit of time

// models spending an abstract unit of time 
// needs to be called at the beginning of every method
// and loop iteration
method consume_time_credit() // 
    requires acc(time_credit(), 1/1)
// -----------------------------------------

// -----------------------------------------
// Object model
// The provided fields are required.
// You can add additional (ghost) fields
// if you want

// a BST node
field elem : Int // value stored in the node
field left : Ref // left child
field right : Ref // right child

// Object for the whole BST, which just stores a 
// pointer to the root node of the tree
field root: Ref 
// -----------------------------------------


// -----------------------------------------
// Utility functions, which you may find useful
function max(a : Int, b : Int) : Int 
    ensures result >= a && result >= b
    ensures result == a || result == b
{
    a > b ? a : b
}

function min(a : Int, b : Int) : Int 
    ensures result <= a && result <= b
    ensures result == a || result == b
{
    a < b ? a : b
}
// -----------------------------------------

// Helper functions for min/max element of a BST node

function min_elem(node: Ref): Int
    requires bst_node(node) && node != null
{
    unfolding bst_node(node) in
        node.left == null ? node.elem : min_elem(node.left)
}

function max_elem(node: Ref): Int
    requires bst_node(node) && node != null
{
    unfolding bst_node(node) in
        node.right == null ? node.elem : max_elem(node.right)
}

// -----------------------------------------
// TASK 4.1: Define a predicate for binary search trees and individual BST nodes.
// You may define additional fields, predicates, arguments or heap-based functions.

// The whole tree has just a reference to the root
// The empty tree is represented by self.root == null
predicate bst(self: Ref)
{
    acc(self.root) &&
    (self.root == null
        ? true
        : bst_node(self.root))
}


// A single BST node. Apart from field permissions, the current value
// must be greater than the largest value in the left subtree and
// smaller than the smallest value in the right subtree.
predicate bst_node(self: Ref)
{
    self == null
        ? true
        : acc(self.elem) && acc(self.left) && acc(self.right) &&
          bst_node(self.left) && bst_node(self.right) &&
          (self.left  == null || max_elem(self.left)  < self.elem) &&
          (self.right == null || self.elem < min_elem(self.right))
}




// -----------------------------------------
// TASK 4.2 - 4.4: implement and verify this method
method bst_insert(tree: Ref, val: Int)
    requires bst(tree)
    // TODO
// -----------------------------------------



// -----------------------------------------
// Auxiliary definition of the height of a tree
function height(tree: Ref) : Int
    requires bst(tree)
    // TODO: define for TASK 4.3
// -----------------------------------------

// -----------------------------------------
// Auxiliary function mapping every BST
// to the set of values it stores.
function to_set(tree: Ref): Set[Int]
    // TODO: define for TASK 4.4
// -----------------------------------------


// test case for 4.1
method test_empty_tree()
{
    var t: Ref := new(root);
    t.root := null;

    // should be able to fold/unfold an empty tree
    fold bst(t);
    unfold bst(t);
}

method test_singleton_tree()
{
    var t: Ref := new(root);
    var n: Ref := new(elem, left, right);

    n.elem  := 5;
    n.left  := null;
    n.right := null;

    // First, build predicates for the (empty) children
    fold bst_node(n.left);    // bst_node(null)
    fold bst_node(n.right);   // bst_node(null)

    // Now we can build the predicate for the node itself
    fold bst_node(n);

    // Wrap it in a tree
    t.root := n;
    fold bst(t);

    // Unfold again just to check everything is consistent
    unfold bst(t);
    unfold bst_node(n);
    unfold bst_node(n.left);
    unfold bst_node(n.right);
}
