// -----------------------------------------
// Runtime model
// Notice that we can hold at most one permission
// to *fields*, but this does not apply to *predicates*
predicate time_credit() // represents one abstract unit of time

// models spending an abstract unit of time 
// needs to be called at the beginning of every method
// and loop iteration
method consume_time_credit() // 
    requires acc(time_credit(), 1/1)
// -----------------------------------------

// -----------------------------------------
// Object model
// The provided fields are required.
// You can add additional (ghost) fields
// if you want

// a BST node
field elem : Int // value stored in the node
field left : Ref // left child
field right : Ref // right child


// Object for the whole BST, which just stores a 
// pointer to the root node of the tree
field root: Ref 
// -----------------------------------------

// -----------------------------------------
// Utility functions, which you may find useful
function max(a : Int, b : Int) : Int 
    ensures result >= a && result >= b
    ensures result == a || result == b
{
    a > b ? a : b
}

function min(a : Int, b : Int) : Int 
    ensures result <= a && result <= b
    ensures result == a || result == b
{
    a < b ? a : b
}
// -----------------------------------------


// -----------------------------------------
// TASK 4.1: Define a predicate for binary search trees and individual BST nodes.
// You may define additional fields, predicates, arguments or heap-based functions.

// The whole tree has just a reference to the root
// The empty tree is represented by self.root == null
predicate bst(self: Ref) {
    acc(self.root) && (self.root != null ==> bst_node(self.root, false, false, 0, 0))
}


// A single BST node. Apart from field permissions, the current value
// must be greater than the largest value in the left subtree and
// smaller than the smallest value in the right subtree.
predicate bst_node(self: Ref, hasMin: Bool, hasMax: Bool, minn: Int, maxx: Int) {
    acc(self.elem) && acc(self.left) && acc(self.right) &&
    (hasMin ==> self.elem > minn) &&
    (hasMax ==> self.elem < maxx) &&
    (self.left != null ==> bst_node(self.left, hasMin, true, minn, self.elem)
    ) &&
    (self.right != null ==> bst_node(self.right, true, hasMax, self.elem, maxx))
}
// -----------------------------------------


// -----------------------------------------
// TASK 4.2 - 4.4: implement and verify this method

method bst_insert(tree: Ref, val: Int)
    requires bst(tree)
    requires acc(time_credit(),(height(tree)+1)/1)
    ensures  bst(tree)
    //4.4
    ensures to_set(tree) == old(to_set(tree)) union Set(val)
{

    consume_time_credit();

    unfold bst(tree);
    if (tree.root == null) {
        // inserting into empty tree
        var newNode: Ref := new(elem, left, right);
        newNode.elem := val;
        newNode.left := null;
        newNode.right := null;
        fold bst_node(newNode, false, false, 0, 0); // arguments were added. Could easily be adapted.
        tree.root := newNode;
    } else {
        // initial call: no bounds yet
        bst_node_insert(tree.root, val, false, false, 0, 0); // arguments were added. Could easily be adapted.
    }
    fold bst(tree);
}

method bst_node_insert(node: Ref, val: Int,
                       hasMin: Bool, hasMax: Bool, minn: Int, maxx: Int)
    requires bst_node(node, hasMin, hasMax, minn, maxx)
    requires (!hasMin || val > minn) && (!hasMax || val < maxx)
    requires acc(time_credit(), height_node(node, hasMin, hasMax, minn, maxx)/1)
    ensures  bst_node(node, hasMin, hasMax, minn, maxx)
    ensures to_set_node(node, hasMin, hasMax, minn, maxx) ==
            old(to_set_node(node, hasMin, hasMax, minn, maxx)) union Set(val)
{

    consume_time_credit();

    unfold bst_node(node, hasMin, hasMax, minn, maxx);

    if (val < node.elem) {
        // go left
        if (node.left == null) {
            // insert here
            var newNode: Ref := new(elem, left, right);
            newNode.elem := val;
            newNode.left := null;
            newNode.right := null;

            // left child has same lower bound, new upper bound = node.elem
            // must satisfy:
            //   hasMin ==> val > minn  (from precondition)
            //   true   ==> val < node.elem (because val < node.elem in this branch)
            fold bst_node(newNode, hasMin, true, minn, node.elem);
            node.left := newNode;
        } else {
            // recurse left with updated bounds
            bst_node_insert(node.left, val, hasMin, true, minn, node.elem);
        }

    } else { if (val > node.elem) {
        // go right
        if (node.right == null) {
            // insert here
            var newNode: Ref := new(elem, left, right);
            newNode.elem := val;
            newNode.left := null;
            newNode.right := null;

            // right child: new lower bound = node.elem, upper bound unchanged
            // must satisfy:
            //   true    ==> val > node.elem (this branch)
            //   hasMax  ==> val < maxx      (from precondition)
            fold bst_node(newNode, true, hasMax, node.elem, maxx);
            node.right := newNode;
        } else {
            // recurse right with updated bounds
            bst_node_insert(node.right, val, true, hasMax, node.elem, maxx);
        }

    } }
    fold bst_node(node, hasMin, hasMax, minn, maxx);
}



// -----------------------------------------



// -----------------------------------------
// Auxiliary definition of the height of a tree
function height(tree: Ref): Int
    requires bst(tree)
    ensures result >= 0
{
    unfolding bst(tree) in
        (tree.root == null ?
            0
         :
            height_node(tree.root, false, false, 0, 0))
}


// Height of a BST subtree rooted at `node`
function height_node(node: Ref, hasMin: Bool, hasMax: Bool, minn: Int, maxx: Int): Int
    requires bst_node(node, hasMin, hasMax, minn, maxx)
    ensures result >= 1
{
    unfolding bst_node(node, hasMin, hasMax, minn, maxx) in
        1 + max(
            node.left == null  ? 0
                                : height_node(node.left, hasMin, true, minn, node.elem),
            node.right == null ? 0
                                : height_node(node.right, true, hasMax, node.elem, maxx)
        )
}

// -----------------------------------------

// -----------------------------------------
// Auxiliary function mapping every BST
// to the set of values it stores.
function to_set(tree: Ref): Set[Int]
    requires bst(tree)
{
    unfolding bst(tree) in
        (tree.root == null ?
            Set()
         :
            to_set_node(tree.root, false, false, 0, 0))
}


// Node-level set of values (no null node case)
function to_set_node(node: Ref, hasMin: Bool, hasMax: Bool, minn: Int, maxx: Int): Set[Int]
    requires bst_node(node, hasMin, hasMax, minn, maxx)
{
    unfolding bst_node(node, hasMin, hasMax, minn, maxx) in
        (
            (node.left  == null
                ? Set()
                : to_set_node(node.left,  hasMin, true,  minn,       node.elem))
          union
            Set(node.elem)
          union
            (node.right == null
                ? Set()
                : to_set_node(node.right, true,  hasMax, node.elem,  maxx))
        )
}

// -----------------------------------------

