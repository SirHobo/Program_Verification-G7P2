// -----------------------------------------
// Runtime model
// Notice that we can hold at most one permission
// to *fields*, but this does not apply to *predicates*
predicate time_credit() // represents one abstract unit of time

predicate time_credits(k: Int)
{
  k <= 0 ? true : time_credit() && time_credits(k - 1)
}

function iters(n: Int) : Int
requires n >= 0
ensures result >= 0
{
    n == 0 ? 0 : 1 + iters(n/2)
}

// models spending an abstract unit of time 
// needs to be called at the beginning of every method
// and loop iteration
method consume_time_credit() // 
    requires acc(time_credit(), 1/1)
// -----------------------------------------

method split_time_credits(a: Int, b: Int)
  requires a >= 0 && b >= 0
  requires time_credits(a + b)
  ensures  time_credits(a) && time_credits(b)
  decreases a + b
{
  if (a == 0) {
    // time_credits(0) is just 'true', and we already have time_credits(b)
    // Nothing to do.
    fold time_credits(0)
  } else {
    // a > 0
    unfold time_credits(a + b)
    // now we have time_credit() && time_credits(a + b - 1)

    split_time_credits(a - 1, b)
    // IH: time_credits(a-1) && time_credits(b)

    // Use the fresh time_credit() and time_credits(a-1) to rebuild time_credits(a)
    fold time_credits(a)
    // We keep time_credits(b) as part of the frame
  }
}


// -----------------------------------------
// Mathematical definition of n^e
function math_pow(n: Int, e: Int): Int
    requires 0 <= e
{
    e == 0 ? 1 : n * math_pow(n, e - 1)
}
// -----------------------------------------

// -----------------------------------------
// You can use this lemma without a proof
method lemma_pow(b: Int, y: Int) 
    requires 0 <= y
    requires y % 2 == 0 // y is even
    ensures math_pow(b, y) == math_pow(b * b, y / 2)
// -----------------------------------------


// -----------------------------------------
// Task 2: Prove a runtime bound for the following recursive method
// Your bound should be tight, i.e. use as few time credits
// as possible. Furthermore, try to prove that it is not possible
// to use fewer time credits.
// Do not modify the given production code. However, feel free to 
// introduce additional functions, lemma methods or ghost code.
// Furthermore, make sure that the functional contract remains intact.
method fast_pow(n: Int, e: Int)
    returns (res: Int)
    requires 0 < e
    requires time_credits(iters(e) + 1)
    ensures res == math_pow(n, e)
{
    unfold time_credits(iters(e) + 1)
    consume_time_credit() // we must spend a credit for every call

    var b: Int := n
    var y: Int := e 
    res := 1

    while (y > 0)
    invariant y >= 0
    invariant math_pow(b,y) * res == math_pow(n,e)
    invariant time_credits(iters(y))
    decreases y
    {
        unfold time_credits(iters(y))
        consume_time_credit() // we must spend a credit for every loop iteration

        if (y % 2 == 1) {
            res := res * b
            lemma_pow(b, y-1)
        } else {
            lemma_pow(b, y)
        }

        y := y / 2
        b := b * b
    }
}
// -----------------------------------------