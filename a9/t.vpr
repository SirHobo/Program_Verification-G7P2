field val: Int

domain Array {
  function loc(a: Array, i: Int): Ref
  function len(a: Array): Int
  function first(r: Ref): Array
  function second(r: Ref): Int

  axiom injectivity {
    forall a: Array, i: Int :: { loc(a, i) }
      first(loc(a, i)) == a && second(loc(a, i)) == i
  }

  axiom length_nonneg {
    forall a: Array :: len(a) >= 0
  }
}

// -------------------------------------------------
// Convenience macros (no types allowed on params)
// -------------------------------------------------

define lookup(a, i)
  (loc(a, i).val)

define update(a, i, e)
{
  loc(a, i).val := e;
}

define array(a)
  (array_p(a, 1/1))

define array_p(a, p)
  (slice_p(a, 0, len(a), p))

define slice(a, l, h)
  (slice_p(a, l, h, 1/1))

define slice_p(a, l, h, p)
  (forall i0: Int :: l <= i0 && i0 < h ==> acc(loc(a, i0).val, p))

// -------------------------------------------------
// Sorting interface
// -------------------------------------------------

// Recursive merge sort on slice [l, h)
method sort_aux(a: Array, l: Int, h: Int)
    requires 0 <= l && l <= h && h <= len(a)
    requires forall i0: Int ::
        l <= i0 && i0 < h ==> acc(loc(a, i0).val, 1/1)
    ensures forall i0$0: Int ::
        l <= i0$0 && i0$0 < h ==> acc(loc(a, i0$0).val, 1/1)
    decreases *
{
    if (h - l <= 1) {
        // already sorted
    } else {
        var m: Int := l + (h - l) / 2;

        sort_aux(a, l, m);
        sort_aux(a, m, h);

        merge(a, l, m, h);
    }
}

// Top-level sort: sorts whole array in place
method sort(a: Array)
  requires array(a)
  ensures  array(a)
{
  sort_aux(a, 0, len(a));
}

// Abstract merge: only spec, no body
method merge(a: Array, l: Int, m: Int, h: Int)
    requires 0 <= l && l <= m && m <= h && h <= len(a)
    requires forall i0: Int ::
        l <= i0 && i0 < m ==> acc(loc(a, i0).val, 1/1)
    requires forall i0$0: Int ::
        m <= i0$0 && i0$0 < h ==> acc(loc(a, i0$0).val, 1/1)
    ensures forall i0$1: Int ::
        l <= i0$1 && i0$1 < h ==> acc(loc(a, i0$1).val, 1/1)
    decreases *
