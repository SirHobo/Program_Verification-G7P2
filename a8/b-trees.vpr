field bt_keys  : Seq[Int]
field bt_child : Seq[Ref]

function bt_sorted(s: Seq[Int]): Bool {
    forall i: Int ::
        0 <= i && i < |s| - 1 ==> s[i] < s[i + 1]
}

// (a) btree predicate
predicate btree_children(cs: Seq[Ref], i: Int, n: Int)
{
    (i < 0 || i >= |cs|)
        ? true
        : btree(cs[i], n) &&
            btree_children(cs, i + 1, n)
}

predicate btree(t: Ref, n: Int)
{
    t == null
        ? true
        : acc(t.bt_keys) && acc(t.bt_child) &&
            bt_sorted(t.bt_keys) &&
            (
                // leaf
                |t.bt_child| == 0
                    ? 1 <= |t.bt_keys| && |t.bt_keys| <= n

                // internal node
                : 2 <= |t.bt_child| && |t.bt_child| <= n &&
                    |t.bt_keys| == |t.bt_child| - 1 &&
                    btree_children(t.bt_child, 0, n)
            )
}

// (b) client
method client()
{
    var l1: Ref;
    var l2: Ref;
    var l3: Ref;
    var r:  Ref;

    // leaves
    l1 := new(bt_keys, bt_child);
    l1.bt_keys  := Seq(1, 2, 5, 6);
    l1.bt_child := Seq[Ref]();
    fold btree(l1, 4);

    l2 := new(bt_keys, bt_child);
    l2.bt_keys  := Seq(9, 12);
    l2.bt_child := Seq[Ref]();
    fold btree(l2, 4);

    l3 := new(bt_keys, bt_child);
    l3.bt_keys  := Seq(18, 21);
    l3.bt_child := Seq[Ref]();
    fold btree(l3, 4);

    // root
    r := new(bt_keys, bt_child);
    r.bt_keys  := Seq(7, 16);
    r.bt_child := Seq(l1, l2, l3);

    // build btree_children(r.bt_child, 0, 4)
    fold btree_children(r.bt_child, 3, 4);
    fold btree_children(r.bt_child, 2, 4);
    fold btree_children(r.bt_child, 1, 4);
    fold btree_children(r.bt_child, 0, 4);

    // now we have everything needed for btree(r,4)
    fold btree(r, 4);
}

// (c) insert
method insert(t: Ref, k: Int)
    requires btree(t, 4)
    ensures  btree(t, 4)
{
  
}

// (d) delete
method delete(t: Ref, k: Int)
    requires btree(t, 4)
    ensures  btree(t, 4)
{

}
