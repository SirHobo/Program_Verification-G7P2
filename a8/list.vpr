field val  : Int
field next : Ref

predicate list(x: Ref)
{
    x == null
        ? true
        : acc(x.val) && acc(x.next) && list(x.next)
}

function content(x: Ref): Seq[Int]
    requires list(x)
{
    unfolding list(x) in
    x == null
        ? Seq[Int]()
        : Seq(x.val) ++ content(x.next)
}

method copy(l: Ref) returns (res: Ref)
    requires list(l)
    ensures  list(l)
    ensures  list(res)
    ensures  content(res) == content(l)
    ensures  content(l) == old(content(l))
{
    if (l == null) {
        res := null;
        // construct the predicate instance list(res)
        fold list(res);
    } else {
        // see head
        unfold list(l);

        // recursively copy the tail
        var tailCopy: Ref := copy(l.next);

        // allocate new head node
        res := new(val, next);
        res.val  := l.val;
        res.next := tailCopy;

        // build predicate for the new list and restore list(l)
        fold list(res);
        fold list(l);
    }
}

// Given
method client(l1: Ref)
    requires list(l1)
    requires content(l1) == Seq(1,2,3,4,5)
{
    var l2: Ref := copy(l1);

    assert content(l1) == Seq(1,2,3,4,5);
    assert content(l2) == Seq(1,2,3,4,5);
}